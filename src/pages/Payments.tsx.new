import React, { useState, useEffect } from "react";
import { Plus, Search } from "lucide-react";
import { useNavigate } from "react-router-dom";
import { Payment, PaymentWithDisplayStatus } from "../types";
import { enhancePaymentWithDisplayStatus } from "../lib/utils/payment";
import PaymentHistoryTable, { SortConfig } from "../components/PaymentHistoryTable";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "../components/ui/table";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "../components/ui/dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "../components/ui/dropdown-menu";
import { Button } from "../components/ui/button";
import { Input } from "../components/ui/input";
import { PaymentForm } from "../components/PaymentForm";
import {
  type PaymentFormValues,
} from "../lib/validations/payment";
import { supabase } from "../lib/supabase";
import { searchByFullName } from "../lib/utils";
import { useNotifications } from "../context/NotificationContext";
import { parseISO } from "date-fns";

const ITEMS_PER_PAGE = 20; // Number of items to load at once

const Payments = () => {
  const navigate = useNavigate();
  const { addNotification } = useNotifications();
  const [searchTerm, setSearchTerm] = React.useState("");
  const [isAddDialogOpen, setIsAddDialogOpen] = React.useState(false);
  const [isEditDialogOpen, setIsEditDialogOpen] = React.useState(false);
  const [payments, setPayments] = React.useState<PaymentWithDisplayStatus[]>(
    []
  );
  const [selectedPayment, setSelectedPayment] = React.useState<Payment | null>(
    null
  );
  const [isLoading, setIsLoading] = React.useState(true);
  const [hasNextPage, setHasNextPage] = React.useState(true);
  const [allPaymentsLoaded, setAllPaymentsLoaded] = React.useState(false);

  // Reference to all payments for virtual scrolling
  const [allPayments, setAllPayments] = React.useState<
    PaymentWithDisplayStatus[]
  >([]);

  // Pagination state for PaymentHistoryTable
  const [currentPage, setCurrentPage] = React.useState(1);
  const [totalPages, setTotalPages] = React.useState(1);
  const [totalRecords, setTotalRecords] = React.useState(0);
  const [displayedPayments, setDisplayedPayments] = React.useState<PaymentWithDisplayStatus[]>([]);

  // Sorting state
  const [sortConfig, setSortConfig] = React.useState<SortConfig>(null);

  // Initial fetch to get all payments and sort them
  const fetchPayments = async () => {
    try {
      setIsLoading(true);
      setPayments([]);
      setDisplayedPayments([]);

      // Fetch all payments with member details
      let { data, error } = await supabase.from("payments").select(
        `
          *,
          member:members!payments_member_id_fkey(first_name, last_name, membership_type)
        `
      );

      if (error) {
        console.error("Supabase query error:", error);
        throw new Error(`Error fetching payments: ${error.message}`);
      }

      // Filter by search term if needed
      let filteredPayments = data || [];
      if (searchTerm) {
        const searchTermLower = searchTerm.toLowerCase();
        filteredPayments = filteredPayments.filter((payment) => {
          const firstName = payment.member?.first_name?.toLowerCase() || "";
          const lastName = payment.member?.last_name?.toLowerCase() || "";
          const fullName = `${firstName} ${lastName}`;

          return (
            firstName.includes(searchTermLower) ||
            lastName.includes(searchTermLower) ||
            fullName.includes(searchTermLower)
          );
        });
      }

      // Enhance payments with display status
      const enhancedPayments = filteredPayments.map((payment) =>
        enhancePaymentWithDisplayStatus(payment as Payment)
      );

      // Store all sorted payments
      setAllPayments(enhancedPayments);
      setAllPaymentsLoaded(true);

      // Calculate pagination
      const total = enhancedPayments.length;
      setTotalRecords(total);
      setTotalPages(Math.ceil(total / ITEMS_PER_PAGE));

      // Update displayed payments based on current page
      updateDisplayedPayments(enhancedPayments, currentPage);

      // For backward compatibility with infinite scroll
      const initialItems = enhancedPayments.slice(0, ITEMS_PER_PAGE);
      setPayments(initialItems);
      setHasNextPage(enhancedPayments.length > ITEMS_PER_PAGE);
    } catch (error: any) {
      console.error("Error fetching payments:", error);
      addNotification({
        title: "Erreur",
        message: `Impossible de récupérer les paiements: ${
          error.message || "Erreur inconnue"
        }`,
        type: "error",
      });
    } finally {
      setIsLoading(false);
    }
  };

  // Helper function to update displayed payments based on current page
  const updateDisplayedPayments = (allPayments: PaymentWithDisplayStatus[], page: number) => {
    const start = (page - 1) * ITEMS_PER_PAGE;
    const end = start + ITEMS_PER_PAGE;
    setDisplayedPayments(allPayments.slice(start, end));
  };

  // Helper function to sort payments by config
  const sortPaymentsByConfig = (payments: PaymentWithDisplayStatus[], config: SortConfig) => {
    if (!config) return payments;

    return [...payments].sort((a, b) => {
      let aValue: any = a[config.key as keyof Payment];
      let bValue: any = b[config.key as keyof Payment];

      // Handle member name sorting
      if (config.key === "member") {
        aValue = `${a.member.first_name} ${a.member.last_name}`;
        bValue = `${b.member.first_name} ${b.member.last_name}`;
      }

      // Handle date sorting
      if (config.key === "due_date" || config.key === "payment_date") {
        aValue = new Date(aValue).getTime();
        bValue = new Date(bValue).getTime();
      }

      if (aValue < bValue) {
        return config.direction === "asc" ? -1 : 1;
      }
      if (aValue > bValue) {
        return config.direction === "asc" ? 1 : -1;
      }
      return 0;
    });
  };

  // Handle sort request
  const handleRequestSort = (key: keyof Payment | "member") => {
    let direction: "asc" | "desc" = "asc";
    if (sortConfig && sortConfig.key === key && sortConfig.direction === "asc") {
      direction = "desc";
    }

    const newConfig = { key, direction };
    setSortConfig(newConfig);

    // Re-sort all payments with the new config
    const sortedPayments = sortPaymentsByConfig(allPayments, newConfig);
    updateDisplayedPayments(sortedPayments, currentPage);
  };

  // Load more items for infinite scrolling
  const loadMoreItems = async () => {
    if (!hasNextPage || !allPaymentsLoaded) return Promise.resolve();

    return new Promise<void>((resolve) => {
      // Simulate a delay to show loading indicator
      setTimeout(() => {
        const nextPage = currentPage + 1;
        const startIndex = nextPage * ITEMS_PER_PAGE;
        const endIndex = startIndex + ITEMS_PER_PAGE;

        // Get the next batch of items
        const newItems = allPayments.slice(startIndex, endIndex);

        if (newItems.length > 0) {
          // Append new items to the current list
          setPayments((prev) => [...prev, ...newItems]);
          setCurrentPage(nextPage);

          // Check if we've loaded all items
          setHasNextPage(endIndex < allPayments.length);
        } else {
          setHasNextPage(false);
        }

        resolve();
      }, 500); // Small delay for better UX
    });
  };

  // Fetch payments when search term changes
  React.useEffect(() => {
    fetchPayments();
  }, [searchTerm]);

  // Update displayed payments when current page changes
  React.useEffect(() => {
    if (allPaymentsLoaded) {
      let paymentsToDisplay = [...allPayments];

      // Apply sort config if available
      if (sortConfig) {
        paymentsToDisplay = sortPaymentsByConfig(paymentsToDisplay, sortConfig);
      }

      updateDisplayedPayments(paymentsToDisplay, currentPage);
    }
  }, [currentPage, allPaymentsLoaded]);

  const handleCreatePayment = async (data: PaymentFormValues) => {
    try {
      const newPayment = {
        member_id: data.memberId,
        amount: data.amount,
        payment_date: data.paymentDate.toISOString(),
        due_date: data.dueDate.toISOString(),
        status: data.status,
        payment_method: data.paymentMethod,
        notes: data.notes || null,
      };

      const { error } = await supabase.from("payments").insert([newPayment]);

      if (error) throw error;

      // If membership type has changed, update the member record
      if (data.membershipType) {
        const { error: memberUpdateError } = await supabase
          .from("members")
          .update({ membership_type: data.membershipType })
          .eq("id", data.memberId);

        if (memberUpdateError) {
          console.error("Error updating member membership type:", memberUpdateError);
          // Don't throw here, we still want to show success for the payment
        }
      }

      // Refresh data to include the new payment
      await fetchPayments();
      setIsAddDialogOpen(false);

      addNotification({
        title: "Succès",
        message: "Paiement enregistré avec succès",
        type: "success",
      });
    } catch (error) {
      console.error("Error creating payment:", error);
      addNotification({
        title: "Erreur",
        message: "Impossible d'enregistrer le paiement",
        type: "error",
      });
    }
  };

  const handleUpdatePayment = async (data: PaymentFormValues) => {
    if (!selectedPayment) return;

    try {
      const updatedPayment = {
        member_id: data.memberId,
        amount: data.amount,
        payment_date: data.paymentDate.toISOString(),
        due_date: data.dueDate.toISOString(),
        status: data.status,
        payment_method: data.paymentMethod,
        notes: data.notes || null,
      };

      const { error } = await supabase
        .from("payments")
        .update(updatedPayment)
        .eq("id", selectedPayment.id);

      if (error) throw error;

      // If membership type has changed, update the member record
      if (data.membershipType) {
        const { error: memberUpdateError } = await supabase
          .from("members")
          .update({ membership_type: data.membershipType })
          .eq("id", data.memberId);

        if (memberUpdateError) {
          console.error("Error updating member membership type:", memberUpdateError);
          // Don't throw here, we still want to show success for the payment
        }
      }

      // Refresh data to include the updated payment
      await fetchPayments();
      setIsEditDialogOpen(false);
      setSelectedPayment(null);

      addNotification({
        title: "Succès",
        message: "Paiement mis à jour avec succès",
        type: "success",
      });
    } catch (error) {
      console.error("Error updating payment:", error);
      addNotification({
        title: "Erreur",
        message: "Impossible de mettre à jour le paiement",
        type: "error",
      });
    }
  };

  const handleDeletePayment = async (id: string) => {
    try {
      const { error } = await supabase.from("payments").delete().eq("id", id);

      if (error) throw error;

      // Refresh data to remove the deleted payment
      await fetchPayments();

      addNotification({
        title: "Succès",
        message: "Paiement supprimé avec succès",
        type: "success",
      });
    } catch (error) {
      console.error("Error deleting payment:", error);
      addNotification({
        title: "Erreur",
        message: "Impossible de supprimer le paiement",
        type: "error",
      });
    }
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-semibold text-gray-900">Paiements</h1>
        <Dialog open={isAddDialogOpen} onOpenChange={setIsAddDialogOpen}>
          <DialogTrigger asChild>
            <Button>
              <Plus className="h-4 w-4 mr-2" />
              Enregistrer un Paiement
            </Button>
          </DialogTrigger>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Enregistrer un Paiement</DialogTitle>
              <DialogDescription>
                Saisissez les details du paiement ci-dessous.
              </DialogDescription>
            </DialogHeader>
            <PaymentForm onSubmit={handleCreatePayment} />
          </DialogContent>
        </Dialog>
      </div>

      <div className="flex items-center space-x-2">
        <Search className="h-5 w-5 text-gray-400" />
        <Input
          placeholder="Rechercher des paiements..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="max-w-sm"
        />
      </div>

      <PaymentHistoryTable
        payments={displayedPayments}
        currentPage={currentPage}
        totalPages={totalPages}
        onPageChange={setCurrentPage}
        isLoading={isLoading}
        sortConfig={sortConfig}
        onRequestSort={handleRequestSort}
        isEditDialogOpen={isEditDialogOpen}
        setIsEditDialogOpen={setIsEditDialogOpen}
        selectedPayment={selectedPayment}
        setSelectedPayment={setSelectedPayment}
        handleUpdatePayment={handleUpdatePayment}
        handleDeletePayment={handleDeletePayment}
        PaymentForm={PaymentForm}
        showActions={true}
      />
    </div>
  );
};

export default Payments;
